#version 450 core

#define MAX_STEP_DISTANCE 100
#define MAX_CHUNKS 64
#define CHUNK_SIZE 32

// 64 on x and 32 on y, but we don't specify that because we divide it on invocation, because we still keep track of those rays in the active_rays variable
layout(local_size_x = 64, local_size_y = 1) in;

layout(rgba32f, binding = 0) writeonly uniform image2D outputImage;

uniform vec3 cameraPos;
uniform mat4 projection;
uniform mat4 view;

mat4 invProjection = inverse(projection);
mat4 invView = inverse(view);

layout(std430, binding = 1) buffer gpu_chunk_location_buffer {
    uint gpu_chunk_location[];
};

layout(std430, binding = 2) buffer gpu_chunk_offset_buffer {
    uint gpu_chunk_offset[];
};

layout(std430, binding = 3) buffer gpu_chunk_data_buffer {
    uint gpu_chunk_data[];
};

layout(std430, binding = 4) buffer output_chunks_buffer {
    vec3 output_buffer[];
};

vec3 getDirectionVector(ivec2 coords) {
    vec2 uv = (vec2(coords) + 0.5) / vec2(imageSize(outputImage));
    vec4 ray_clip = vec4(uv * 2.0 - 1.0, -1.0, 1.0);
    vec4 ray_eye = invProjection * ray_clip;
    ray_eye = vec4(ray_eye.xy, -1.0, 0.0);
    return normalize((invView * ray_eye).xyz);
}

bool voxelIntersection(vec3 position) {
    ivec3 voxelCoord = ivec3(floor(position / CHUNK_SIZE));

    // Retrieve chunk index and bit offset
    uint chunkIndex = gpu_chunk_location[voxelCoord.x + voxelCoord.y * MAX_CHUNKS + voxelCoord.z * MAX_CHUNKS * MAX_CHUNKS];
    uint bitOffset = voxelCoord.y % 32;

    if (chunkIndex <= 0) {
        output_buffer[gl_GlobalInvocationID.y] = voxelCoord;
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 1.0));
        return false;
    }

    // Calculate the index in the gpu_chunk_data buffer
    uint chunkDataIndex = gpu_chunk_offset[chunkIndex];

    // Retrieve the voxel data for the specified vertical column
    uint voxelColumn = gpu_chunk_data[chunkDataIndex];

    // Check if the bit corresponding to the voxelCoord.y is set
    return (voxelColumn & (1 << bitOffset)) != 0;
}

void main() {
    // each ray has 32 vertical rays represented as a bit field mask for each ray that has 32 vertical rays
    uint active_rays = 0xFFFFFFFF;

    // get the up and down vectors, todo: don't handle the up and down rotation
    vec3 up = getDirectionVector(ivec2(gl_GlobalInvocationID.xy)); // up vector of the first ray
    vec3 down = getDirectionVector(ivec2(gl_GlobalInvocationID.x, (gl_GlobalInvocationID.y * 32) + 32)); // down vector of the last ray
    // we can calculate each rays direction by interpolating the up and down vectors

    vec3 ray_dir[32];
    for (int i = 0; i < 32; i++) {
        float t = float(i) / 31.0;
        ray_dir[i] = normalize(mix(up, down, t));
    }

    vec3 ray_pos[32];
    for (int i = 0; i < 32; i++) {
        ray_pos[i] = cameraPos;
    }

    for (int step = 0; step < MAX_STEP_DISTANCE; step++) {
        for (int i = 0; i < 32; i++) {
            if ((active_rays & (1 << i)) == 0) continue; // skip inactive rays

            ray_pos[i] += ray_dir[i];

            if (voxelIntersection(ray_pos[i])) {
                active_rays &= ~(1 << i);
            } else {
                return;
            }
        }

        if (active_rays == 0) break; // if all rays are inactive, break the loop
    }

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0 - float(active_rays != 0)));


    // // main rays loop
    // for (int step = 0; step < MAX_STEP_DISTANCE; step++)
    // {
        
    // }

    // // write the rays result to the output image
    // for (int i = 0; i < 32; i++) {
    //     imageStore(outputImage, ivec2(gl_GlobalInvocationID.x, (gl_GlobalInvocationID.y * 32) + i), vec4(1.0));
    // }
}